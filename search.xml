<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[String、StringBuffer与StringBuilder的区别]]></title>
    <url>%2Fposts%2F272f3f11%2F</url>
    <content type="text"><![CDATA[String类String类基础知识1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; 通过查看String类源码（jdk1.8）可以归纳出： String类被final修饰符修饰，所以String类不能被继承。它的成员方法都默认是final方法。 对String对象的任何改变都不影响到原对象， 相关的任何change操作都会生成新的对象。 String类是通过char数组来保存字符串的，而String类的一些方法（substring,replace,concat）等操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 深入理解String类123456789101112public class Main &#123; public static void main(String[] args) &#123; String str1 = "hello world"; String str2 = new String("hello world"); String str3 = "hello world"; String str4 = new String("hello world"); System.out.println(str1==str2); //false System.out.println(str1==str3); //true System.out.println(str2==str4); //false &#125;&#125; 在上述代码中，String str1 = &quot;hello world&quot;;和String str3 = &quot;hello world&quot;;都在编译期间生成了字面常量和符号引用，运行期间字面常量&quot;hello world&quot;被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。 通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。 String、StringBuffer以及StringBuilder的区别既然在Java中已经存在了String类，那为什么还需要StringBuilder和StringBuffer类呢？那么看下面这段代码： 12345678public class StringDemo &#123; public static void main(String[] args) &#123; String string = ""; for(int i=0;i&lt;10000;i++)&#123; string += "hello"; &#125; &#125;&#125; 这句 string += “hello”;的过程相当于将原有的string变量指向的对象内容取出与”hello”作字符串相加操作再存进另一个新的String对象当中，再让string变量指向新生成的对象。如果大家还有疑问可以反编译其字节码文件便清楚了： 1234567891011121314151617181920212223242526272829public class com.kotlin.StringDemo &#123; public com.kotlin.StringDemo(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String 2: astore_1 3: iconst_0 4: istore_2 5: iload_2 6: sipush 10000 9: if_icmpge 38 12: new #3 // class java/lang/StringBuilder 15: dup 16: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 19: aload_1 20: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 23: ldc #6 // String hello 25: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_1 32: iinc 2, 1 35: goto 5 38: return&#125; 从这段反编译出的字节码文件可以很清楚地看出：从第12行开始到第35行是整个循环的执行过程，并且每次循环会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象。也就是说这个循环执行完毕new出了10000个对象，试想一下，如果这些对象没有被回收，会造成多大的内存资源浪费。 从上面还可以看出：string+=”hello”的操作事实上会自动被JVM优化成： 123StringBuilder str = new StringBuilder(string);str.append("hello");str.toString(); 再看下面这段代码 12345678public class StringDemo &#123; public static void main(String[] args) &#123; StringBuilder stringBuilder = new StringBuilder(); for(int i=0;i&lt;10000;i++)&#123; stringBuilder.append("hello"); &#125; &#125;&#125; 反编译字节码文件得到： 1234567891011121314151617181920212223242526public class com.kotlin.StringDemo &#123; public com.kotlin.StringDemo(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class java/lang/StringBuilder 3: dup 4: invokespecial #3 // Method java/lang/StringBuilder."&lt;init&gt;":()V 7: astore_1 8: iconst_0 9: istore_2 10: iload_2 11: sipush 10000 14: if_icmpge 30 17: aload_1 18: ldc #4 // String hello 20: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 23: pop 24: iinc 2, 1 27: goto 10 30: return&#125; 从这里可以明显看出，这段代码的for循环式从17行开始到27行结束，并且new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。 那么有人会问既然有了StringBuilder类，为什么还需要StringBuffer类？查看源代码便一目了然，事实上，StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说StringBuffer是线程安全的。 下面摘了2段代码分别来自StringBuffer和StringBuilder，insert方法的具体实现： StringBuilder的insert方法 123456public StringBuilder insert(int index, char[] str, int offset, int len) &#123; super.insert(index, str, offset, len); return this; &#125; StringBuffer的insert方法： 12345678@Overridepublic synchronized StringBuffer insert(int index, char[] str, int offset, int len) &#123; toStringCache = null; super.insert(index, str, offset, len); return this; &#125; 性能测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class StringDemo &#123; private static int time = 50000; public static void main(String[] args) &#123; testString(); testStringBuffer(); testStringBuilder(); test1String(); test2String(); &#125; public static void testString () &#123; String s=""; long begin = System.currentTimeMillis(); for(int i=0; i&lt;time; i++)&#123; s += "java"; &#125; long over = System.currentTimeMillis(); System.out.println("操作"+s.getClass().getName()+"类型使用的时间为："+(over-begin)+"毫秒"); &#125; public static void testStringBuffer () &#123; StringBuffer sb = new StringBuffer(); long begin = System.currentTimeMillis(); for(int i=0; i&lt;time; i++)&#123; sb.append("java"); &#125; long over = System.currentTimeMillis(); System.out.println("操作"+sb.getClass().getName()+"类型使用的时间为："+(over-begin)+"毫秒"); &#125; public static void testStringBuilder () &#123; StringBuilder sb = new StringBuilder(); long begin = System.currentTimeMillis(); for(int i=0; i&lt;time; i++)&#123; sb.append("java"); &#125; long over = System.currentTimeMillis(); System.out.println("操作"+sb.getClass().getName()+"类型使用的时间为："+(over-begin)+"毫秒"); &#125; public static void test1String () &#123; long begin = System.currentTimeMillis(); for(int i=0; i&lt;time; i++)&#123; String s = "I"+"love"+"java"; &#125; long over = System.currentTimeMillis(); System.out.println("字符串直接相加操作："+(over-begin)+"毫秒"); &#125; public static void test2String () &#123; String s1 ="I"; String s2 = "love"; String s3 = "java"; long begin = System.currentTimeMillis(); for(int i=0; i&lt;time; i++)&#123; String s = s1+s2+s3; &#125; long over = System.currentTimeMillis(); System.out.println("字符串间接相加操作："+(over-begin)+"毫秒"); &#125;&#125; 测试结果 操作java.lang.String类型使用的时间为：10645毫秒操作java.lang.StringBuffer类型使用的时间为：4毫秒操作java.lang.StringBuilder类型使用的时间为：3毫秒字符串直接相加操作：1毫秒字符串间接相加操作：9毫秒 由上面的执行结果可以看出： 对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如”I”+”love”+”java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。这个可以用javap -c命令反编译生成的class文件进行验证。 对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。 String、StringBuilder、StringBuffer三者的执行效率 StringBuilder &gt; StringBuffer &gt; String 当然这个是相对的，不一定在所有情况下都是这样。 比如String str = “hello”+ “world”的效率就比 StringBuilder st = new StringBuilder().append(“hello”).append(“world”)要高。 总结： 当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式； 当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。 常见的关于String、StringBuffer的面试题 下面这段代码的输出结果是什么？ String a = “hello2”; String b = “hello” + 2; System.out.println((a == b)); 输出结果为:true。原因很简单，”hello”+2在编译期间就已经被优化成”hello2”，因此在运行期间，变量a和变量b指向的是同一个对象。 下面这段代码的输出结果是什么？ String a = “hello2”; String b = “hello”; String c = b + 2 System.out.println((a == b)); 输出结果为:false。由于有符号引用的存在，所以String c = b + 2;不在在编译期间被优化，不会把b + 2当作字面常量来处理，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的不是同一个对象。 下面这段代码的输出结果是什么？ String a = “hello2”; final String b = “hello”; String c = b + 2; System.out.println((a == c)); 输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = “hello” + 2; 下面这段代码输出结果为： 123456789101112public class StringDemo &#123; public static void main(String[] args) &#123; String a = "hello2"; final String b = getHello(); String c = b + 2; System.out.println((a == c)); &#125; public static String getHello() &#123; return "hello"; &#125;&#125; 输出结果为false。这里面虽然将b用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此a和c指向的不是同一个对象。 下面这段代码的输出结果是什么？ 12345678910111213public class StringDemo &#123; public static void main(String[] args) &#123; String a = "hello"; String b = new String("hello"); String c = new String("hello"); String d = b.intern(); System.out.println(a==b); System.out.println(b==c); System.out.println(b==d); System.out.println(a==d); &#125;&#125; 输出结果为 falsefalsefalsetrue 这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。 String str = new String(“abc”)创建了多少个对象？ 首先必须弄清楚创建对象的含义，创建是什么时候创建的？这段代码在运行期间会创建2个对象么？毫无疑问不可能，用javap -c反编译即可得到JVM执行的字节码内容： 12345678910111213141516public class com.kotlin.StringDemo &#123;public com.kotlin.StringDemo(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: returnpublic static void main(java.lang.String[]); Code: 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V 9: astore_1 10: return&#125; 很显然，new只调用了一次，也就是说只创建了一个对象。 而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了”abc”对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念 该段代码执行过程和类的加载过程是有区别的。在类加载的过程中，确实在运行时常量池中创建了一个”abc”对象，而在代码执行过程中确实只创建了一个String对象。 因此，这个问题如果换成 String str = new String(“abc”)涉及到几个String对象？合理的解释是2个。 个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚”是这段代码执行过程中创建了多少个对象还是涉及到多少个对象“再根据具体的来进行回答。]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基本类型与包装类]]></title>
    <url>%2Fposts%2F61d7e5c9%2F</url>
    <content type="text"><![CDATA[基本数据类型java中的基本数据类型有byte,char,boolean,short,int,long, float,double byte：1个字节，最大存储数据量是255，存放的数据范围是-128~127之间。 short：2个字节，最大数据存储量是65536，数据范围是-32768~32767之间。 int：4个字节，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。 long：8个字节，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。 float：4个字节，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F，float的精度为6-7位有效数字。 double：8个字节，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加（默认double类型），double的精度位15-16位有效数字。 boolean：1个字节 只有true和false两个取值。 char：2个字节，存储Unicode码，用单引号赋值。 数据类型转换： 基本数据类型包装类java为每一个基本数据类型都引入了对应的包装类型（wrapper class）,并从java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 包装类类型：Byte,Character,Boolean,Short,Integer,Long,Float,Double 自动装箱:将基本数据类型重新转化为对象12345678public class Test &#123; public static void main(String[] args) &#123; //声明一个Integer对象 Integer num = 9; //以上的声明就是用到了自动的装箱：解析为:Integer num = new Integer(9); &#125; &#125; 9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的，但jdk1.5后你就可以进行这样的声明。自动将基本数据类型转化为对应的封装类型，成为一个对象以后就可以调用对象所声明的所有的方法。 自动拆箱:将对象重新转化为基本数据类型123456789public class Test &#123; public static void main(String[] args) &#123; //声明一个Integer对象 Integer num = 9; //进行计算时隐含的有自动拆箱 System.out.print(num--); &#125; &#125; 使用场景 一般POJO类中使用包装类型，而在本地变量中推荐使用基本类型 使用容器时，只能存储对象，不能存储基本数据类型（List,Set,Map） 考试成绩为0和缺考的区别（用Integer可以，int不行） Integer与int的区别Integer与int的基本使用对比 Integer是int的包装类，int则是java的一种基本数据类型 Integer变量必须实例化后才能使用，而int变量不需要 Integer实际是对象的引用，指向new出的Integer对象，而int则直接存储数据值 Integer的默认值是null，int的默认值是0 Integer与int的深入对比 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false Integer变量和int变量比较时，只要两个变量的值时相等的，则结果为true(因为包装类Integer和基本数据类型int比较时，java会自动拆包为int，然后进行比较，实际上就变为两个int变量的比较)。 123Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象,而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） 123Integer i = new Integer(1000);Integer j = 1000;System.out.print(i == j); //false 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true,如果两个变量的值不在此区间，则比较的结果为false。 123456789public static void main (String[] args) &#123; Integer i = 100; Integer j = 100; System.out.print(i == j); //true Integer i = 128; Integer j = 128; System.out.print(i == j); //false&#125; 原因:java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; Integer源码分析给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，源码如下：12345678910111213public static Integer valueOf(String s, int radix) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s,radix));&#125;public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10));&#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; java对于Integer与int的自动装箱与拆箱的设计，是一种模式：叫享元模式（flyweight）。 加大对简单数字的重利用，Java定义在自动装箱时对于值从–128到127之间的值，它们被装箱为Integer对象后，会存在内存中被重用，始终只存在一个对象。 而如果超过了从–128到127之间的值，被装箱后的Integer对象并不会被重用，即相当于每次装箱时都新建一个 Integer对象。 IntegerCache是Integer的内部类，源码如下:1234567891011121314151617181920212223242526272829303132private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[hashCode方法和equals方法]]></title>
    <url>%2Fposts%2F142beca2%2F</url>
    <content type="text"><![CDATA[hashCode方法和equals方法都是java.lang.Object类的方法。equals方法是判断两个对象是否相等的方法，而hashCode方法则是为散列数据结构服务的计算散列值的方法。 equals方法equals方法注重两个对象在逻辑上是否相等。重写equals方法需要遵循以下规则： 自反性: 一个对象与自身相等，即x = x。 对于任何非空对象x，x.equals(x)必定为true。 对称性: 对象之间的等价关系是可交换的，即a = b ⇔ b = a。对于任何非空对象x,y。x.equals(y)为true,则y.equals(x)一定也为true。 传递性: (a = b)∧( b = c) ⇒ (a = c)。对于任何非空对象x、y、z,若x.equals(y)为true且y.equals(z)为true,则x.equals(z)为true. 一致性: 对于任何非空l对象x,y，只要所比较的信息未变，则连续调用x.equals(y)总是得到一致的结果。 对于任何非空对象x,x.equals(null)必定为false。 重写规则 首先判断传入的对象与自身是否为同一对象，如果是的话直接返回true。这相当于一种性能优化，尤其是在对象比较操作代价高昂的时候，这种优化非常有效。 判断对象是否为正确的类型。若此方法接收子类，即子类判断相等的逻辑与父类相同，则可以用instanceof操作符；若逻辑不同，即仅接受当前类型，则可以用getClass方法获取Class对象来判断。注意使用getClass方法时，必须保证非空，而用instanceof操作符则不用非空验证(null instanceof object 的值为false)。 将类型转换为相应的类型，由于前面已经做过校验，因此这里做类型转换的时候不应当抛出ClassCastException异常。 编写相关的判断逻辑。简单的示例如下： 123456789101112131415161718192021222324252627282930class Fucker &#123; private int id; private String name; public Fucker(int id, String name) &#123; this.id = id; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; //使用instanceof来判断类型，不需要非空验证 if (!(o instanceof Fucker)) return false; //使用getClass方法来判断类型，需要做非空验证 /* if (o == null || getClass() != o.getClass()) return false; */ Fucker fucker = (Fucker) o; return id == fucker.id &amp;&amp; !(name != null ? !name.equals(fucker.name) : fucker.name != null); &#125; @Override public int hashCode() &#123; int result = id; result = 31 * result + (name != null ? name.hashCode() : 0); return result; &#125;&#125; 注意事项 我们无法在扩展一个可实例化的类的同时，即增加新的成员变量，同时又保留原先的equals约定 不要写错equals方法的参数类型，标准的应该是public boolean equals(Object o),若写错就变成重载而不是重写。 如果重写了equals方法，则一定要重写hashCode方法。 equals和==的区别equals方法用来判断两个对象在逻辑上是否相等，而==用来判断两个对象是否为同一个对象,即两个对象地址是否相同。如果两个对象是基本数据类型（byte,short,char,int,long,float,double,boolean）则比较的是基本类型的字面值。123456789101112String str1 = "Fucking Scala";String str2 = new String("Fucking Scala");String str3 = new String("Fucking Scala");String str4 = "Fucking Scala";System.out.println(str1 == str2); // falseSystem.out.println(str2 == str3); // falseSystem.out.println(str2.equals(str3)); // trueSystem.out.println(str1 == str4); // truestr4 = "Fuck again!";String str5 = "Fuck again!";System.out.println(str1 == str4); // falseSystem.out.println(str4 == str5); // true hashCode方法如果重写了equals方法，则一定要重写hashCode方法。重写hashCode方法的原则如下： 在程序执行期间，只要equals方法的比较操作，用到的信息没有被修改，那么对这同一个对象调用多次hashCode方法,必须始终如一地返回同一个整数。 如果两个对象通过equals方法比较得到的结果是相等的，那么对这两个对象hashCode得到的值应该相同。 两个不同的对象，hashCode的结果可能是相同的，这就是哈希表中的冲突，为了保证哈希表的效率，哈希算法应尽可能的避免冲突。 建议： 永远不要让哈希算法返回一个常值，这时哈希表将退化成链表，查找时间复杂度也从O(1)退化到O(N)。 如果参数是boolean类型，计算(f ? 1 : 0) 如果参数是byte，char，short或者int类型，计算(int)f 如果参数是long类型，计算(int)(f ^ (f &gt;&gt;&gt; 32)) 如果参数是float类型，计算Float.FloatToIntBits(f) 如果参数是double类型，计算Double.doubleToLongBits(f)得到long类型的值，再根据公式计算出相应的hash值 如果参数是Object类型，那么应计算其有用的成员变量的hash值，并按照下面的公式计算最终的hash值 如果参数是个数组，那么把数组中的每个值都当作单独的值，分别按照上面的方法单独计算hash值，最后按照下面的公式计算最终的hash值 组合公式 result = 31 * result + c 例子: String类的hashCode方法如下（jdk 1.8）1234567891011public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 自定义类的hashCode123456789101112131415161718192021222324252627282930class Duck &#123; private int id; private String name; private double weight; private float height; private String note; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Duck duck = (Duck) o; if (id != duck.id) return false; if (Double.compare(duck.weight, weight) != 0) return false; if (Float.compare(duck.height, height) != 0) return false; if (name != null ? !name.equals(duck.name) : duck.name != null) return false; return !(note != null ? !note.equals(duck.note) : duck.note != null); &#125; @Override public int hashCode() &#123; int result; long temp; result = id; result = 31 * result + (name != null ? name.hashCode() : 0); temp = Double.doubleToLongBits(weight); result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32)); result = 31 * result + (height != +0.0f ? Float.floatToIntBits(height) : 0); result = 31 * result + (note != null ? note.hashCode() : 0); return result; &#125;&#125; hashCode在集合类(HashMap，HashSet等）操作中使用，为了提高查询速度。将对象放入集合中，首先判断要放入对象的hashcode值与集合中任意一个元素的hashCode值是否相等，如果不相等直接将该对象放入集合中。如果hashCode值相等，然后再通过equals方法判断要放入对象与该对象是否相等，如果equals判断不相等，则将该元素放入到集合中，否则不放入。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Volley源码分析]]></title>
    <url>%2Fposts%2F584afc42%2F</url>
    <content type="text"><![CDATA[Volley 简介Volley是Google推出的Android异步网络请求框架和图片加载框架。在Google I/O 2013大会上发布。 Volley的特点: 支持多个并发网络请求。 支持请求优先级。 支持网络请求缓存。 支持取消网络请求（单个or一组）。 容易自定义/扩展。 所以，Volley特别适合数据量小，通信频繁的网络应用开发,由于Volley会将Response解析到内存中，所以不适合大数据下载。 总体设计总体设计图 Volley主要是通过两种Dispatch Thread不断从Request Queue中取出请求，根据是否已缓存调用Cache或Network这两个类的数据获取接口，从内存缓存或是服务器取得请求的数据，然后交由ResponseDelivery去做结果分发及回调处理。 Volley中关键类介绍Volley的调用比较简单，通过newRequestQueue(…)函数新建并启动一个请求队列RequestQueue后，只需要往这个RequestQueue不断add Request即可。 Volley:volley对外暴露的API，通过newRequestQueue(…)函数新建并启动一个请求队列RequestQueue。 Request:表示一个请求的抽象类。StringRequest,JsonRequest,ImageRequest都是它的子类，表示某种类型的请求。 RequestQueue:表示请求队列，里面包含一个CacheDispatcher(用于处理走缓存请求的调度线程)、NetworkDispatcher数组(用于处理走网络请求的调度线程)，一个ResponseDelivery(返回结果分发接口),通过start()函数启动时会启动NetworkDispatcher，CacheDispatcher。 CacheDispatcher:一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。当结果未缓存过，缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度请求。 NetworkDispatcher:一个线程，用于调度处理走网络的请求。启动后不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。 ResponseDelivery:返回结果分发，目前只有基于ExecutorDelivery的，在入参handler对应线程内进行分发。 BaseHttpStack:处理Http请求，返回请求结果。目前Volley中有基于HttpUrlConnection的HurlStack和基于Apache HttpClient的HttpClientStack。由于目前不需要考虑API&lt;9的情况，故HttpClientStack不需要考虑。HttpClientStack通过AdaptedHttpStack转换为BaseHttpStack。 Network:调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。 Cache:缓存请求结果，Volley默认使用的是基于Cache目录的DiskBasedCache。NetworkDispatcher得到请求结果后判断是否需要存储在Cache，CacheDispatcher会从Cache中取缓存结果。 请求流程图 详细设计类关系图 图中红色圈内的部分，组成Volley框架的核心，围绕RequestQueue类，将各个功能点以组合的方式结合在了一起。各个功能点也都是以接口或者抽象类的形式提供。红色圈外面的部分，在Volley源码中放在了toolbox包中，作为Volley为各个功能点提供的默认的具体实现。通过类图我们看出，Volley有着非常好的拓展性。通过各个功能点的接口，我们可以给出自定义的，更符合我们需求的具体实现。 多用组合，少用继承；针对接口编程，不针对具体实现编程 核心类功能介绍Volley.java这个和Volley框架同名的类，其实是个工具类，作用是构建一个可用于添加网络请求的RequestQueue对象。 Volley.java有两个重载的静态方法 123public static RequestQueue newRequestQueue(Context context)public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) 第一个方法的实现调用了第二个方法，通过BaseHttpStack创建一个代表网络(Network)的具体实现BaseNetwork，接着构造一个代表缓存(Cache)的基于Disk的具体实现DiskBasedCache。最后将网络(Network)对象和缓存(Cache)对象传入构建一个RequestQueue，启动这个RequestQueue，并返回。 1234File cacheDir = new File(context.getCacheDir(),DEFAULT_CACHE_DIR);RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);queue.start();return queue; 我们平时大多采用Volley.newRequestQueue(context)的默认实现，构建RequestQueue。通过源码可以看出，我们可以抛开Volley工具类构建自定义的RequestQueue，采用自定义的BaseHttpStack，采用自定义的Network实现，采用自定义的Cache实现等来构建RequestQueue。优秀框架的高可拓展性的魅力来源于此啊 Request.java代表一个网络请求的抽象类。我们通过构建一个Request类的非抽象子类(StringRequest,JsonRequest,ImageRequest或自定义)对象，并将其加入到RequestQueue中来完成一次网络请求操作。Volley支持8种Http请求方式GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCH。Request类中包含了请求url,请求方式，请求Header，请求Body，请求的优先级等信息。 因为是抽象类，子类必须重写的两个方法。 1abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response); 子类重写此方法，将网络返回的原生字节内容，转换成合适的类型。此方法会在工作线程中被调用。1abstract protected void deliverResponse(T response); 子类重写此方法，将解析成合适类型的内容传递给他们的监听回调。 以下两个方法也经常会被重写 1public byte[] getBody() 重写此方法，可以构建用于POST, PUT, PATCH请求方式的Body内容。1protected Map&lt;String, String&gt; getParams() 在上面getBody函数没有被重写情况下，此方法的返回值会被key，value分别编码后拼接起来转换为字节码作为Body内容。 RequestQueue.javaVolley框架的核心类，将请求Request加入到一个运行的RequestQueue中，来完成请求操作。 主要成员变量 RequestQueue中维护了两个基于优先级的Request队列，缓存请求队列和网络请求队列。 12private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = new PriorityBlockingQueue&lt;&gt;();private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = new PriorityBlockingQueue&lt;&gt;(); 维护了一个正在进行中，尚未完成的请求集合 1private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;&gt;(); 启动队列 创建出RequestQueue以后，调用start()方法，启动队列。 123456789101112131415/** Starts the dispatchers in this queue. */public void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; start()方法中，开启一个缓存调度线程CacheDispatcher 和4个 网络调度线程NetworkDispatcher。缓存调度线程不断的从缓存请求队列中取出Request去处理，网络调度线程不断的从网络请求队列中取出Rqeust去处理。 处理流程图 CacheDispatcher.java一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。 主要成员变量 BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue;缓存请求队列 BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue;网络请求队列 Cache mCache;缓存类，代表了一个可以获取请求结果，存储请求结果的缓存 ResponseDelivery mDelivery;请求结果传递类 WaitingRequestManager mWaitingRequestManager 处理流程图 NetworkDispatcher.java一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中请求处理，队列为空则等待，请求处理结束则将结果传递给RespondeDelivery去执行后续处理。并判断结果是否要进行缓存。 主要成员变量 BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue 网络请求队列 Network mNetwork 网络类，代表了一个可以执行请求的网络 Cache mCache 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存 ResponseDelivery mDelivery 请求结果传递类，可以传递请求的结果或者错误到调用者 处理流程]]></content>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2Fposts%2F423abe9e%2F</url>
    <content type="text"><![CDATA[新建代码库1234567891011# 在当前目录下新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] [project-name]# 将本地仓库，关联到远程仓库$ git remote add origin [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置） 123456789101112# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e --global# 设置提交代码时的用户信息$ git config --global user.name "[name]"$ git config --global user.email "[email-address]"# 让git适当地显示不同的颜色$ git config --global color.ui true 增加/删除文件123456789101112131415161718# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .$ git add -A# 删除工作区文件，并且将这次删除放入暂存区（会删除工作区，暂存区或分支上的文件）$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区（只删除暂存区或分支上的文件，本地工作区会保留）$ git rm --cached [file]# 改名文件，并且将这个文件放入暂存区$ git mv [file-original] [file-renamed] 代码提交1234567891011121314# 提交暂存区到仓库区$ git commit -m "[message]"# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m "[message]"# 提交暂存区所有文件到仓库区$ git commit -am "[message]"# 使用一次新的commit，替代上一次提交，主要用来修改上一次commit的提交信息$ git commit --amend -m "[message]"# 重做上一次commit,并包括指定文件的新变化$ git commit --amend [file1] [file2] ... -m "[message]" 分支12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch-name]# 新建一个分支，指向指定的commit$ git branch [branch-name] [commit-id]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch-name] [remote/branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream-to [branch-name] [remote/branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]$ git push origin :feature_x# 删除远程分支在本地的映射$ git remote prune origin 标签1234567891011121314151617181920212223242526272829# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit-id]# 创建分支并指定标签说明信息$ git tag -a [tag] -m [message]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tag]# 查看tag及tag上的标签说明信息$ git show [tag]# 提交指定tag$ git push origin [tag]# 提交所有tag$ git push origin --tags# 新建一个分支，指向某个tag$ git checkout -b [branch-name] [tag] 查看信息123456789101112131415161718192021222324252627282930# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 根据关键词，搜素提交历史$ git log -S [keyword]# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [commit-id]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD 远程同步1234567891011# 下载远程仓库的所有变动$ git fetch [remote]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 提交本地分支feature-x作为远程feature-x分支$ git push origin feature-x:feature-x# 推送所有分支到远程仓库$ git push [remote] --all 撤销123456789101112131415161718192021222324252627# 用暂存区的指定文件覆盖工作区的该文件$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit-id] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]$ git reset HEAD [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 将commit-id之前的commit全部取消，但文件改动还存在，可以重新add，commit$ git reset --soft commit-id# 重置当前分支的指针为指定commit,同时重置暂存区，但工作区不变$ git reset [commit-id]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit-id]# 撤销过去5个commit提交，但文件改动还存在，可以重新提交$ git reset HEAD~5 其它1234567891011121314151617# 查看git历史命令记录$ git reflog# 将工作区改动放到存储区/缓存区$ git stash# 查看存储区/缓存区的列表$ git stash list# 恢复缓存区的文件$ git stash apply# 删除缓存区$ git stash drop# 恢复缓存区的文件并删除缓存区$ git stash pop]]></content>
  </entry>
</search>
